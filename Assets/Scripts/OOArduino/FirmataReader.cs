// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
/* FirmataReceiver.cs
 *
 * Released under MIT license: http://www.opensource.org/licenses/mit-license.php
 * Copyright (C) 2015   Douwe A. van Twillert - Art & Technology, Saxion
 */

using System;
using System.IO;
using System.IO.Ports;
using System.Collections.Generic;

using Utilities;
using UnityEngine;


namespace OOArduino
{
	partial class LowLevelArduino
	{
		partial class Firmata 
		{
		
			#region FirmateReader

			/**
			 * @private
			 * @author Douwe A. van Twillert, Saxion
			 * The FirmataCommandReceiver class receives commands according to the Firmata V2 protocol.
			 * Works with an Arduino and the StandardFirmata firmware.
			 * Based on ideas from Erik Sjodin, eriksjodin.net Bjoern Hartmann, bjoern.org and
			 * Mochammad Effendi (Arduino Mega)
			 * @author Douwe A. van Twillert, Saxion
			 */
			// =========
			// Variables
			// =========
			private List<byte> _readBuffer = null;

			public void ReadUpdate()
			{
				//Debug.Log ( ">>> ReadBuffer()" );
				//OpenSerialPortIfNecessary();
				//Debug.Log ( "=== ReadBuffer()" );
				if ( _serial.IsOpen && _serial.BytesToRead > 0 ) {
					ProcessReadBytes();
				}
				//Debug.Log ( "<<< ReadBuffer()" );
			}
			
			
			private void ProcessReadBytes()
			{
				try {
					if ( IsStillScanningForFirmwareVersion() ) {
						ScanForFirmwareVersion();
						if ( IsStillScanningForFirmwareVersion() )
							return;
					}
					while ( _serial.BytesToRead > 0 ) {
						_readBuffer.Add( (byte) _serial.ReadByte() );
					}
					while ( _readBuffer.Count > 0 && IsAFullMessageAvailable() ) {
						ProcessMessage();
					}
				} catch ( Exception exception ) {
					Debug.Log( "error caught while decoding arduino command message:" );
					Debug.Log( "error =" + exception );
					Debug.Log( exception.StackTrace );
					
					throw exception;
				}
			}
			
	/*		
			protected function onSocketClose( event : Event ) : void
			{
				_readBuffer = null;
			}
	*/		
			

			// =================
			// Private functions
			// =================
			private Boolean IsStillScanningForFirmwareVersion()
			{
				return _readBuffer == null;
			}
			
			
			private void ScanForFirmwareVersion()
			{
				int data;
				do {
					data = _serial.BytesToRead > 0 ? (byte)_serial.ReadByte() : -1;
				} while ( data != (int)Commands.REPORT_VERSION && data != -1 );
					
				if ( data == (int) Commands.REPORT_VERSION ) {
					_readBuffer = new List<byte>();
					_readBuffer.Add( (byte)data );
				}
			}


			private Boolean IsAFullMessageAvailable()
			{
				Debug.Assert( _readBuffer.Count > 0 );
				
				Firmata.Commands command = GetCommandWithoutChannel( _readBuffer[0] ) ;
				switch( command ) {
				case Commands.DIGITAL_MESSAGE:
				case Commands.REPORT_VERSION:
				case Commands.ANALOG_MESSAGE:
					return _readBuffer.Count > 2;
				case Commands.SYSEX_START:
					for ( int i = 1 ; i < _readBuffer.Count ; i++ ) {
						if ( _readBuffer[i] == (byte) Commands.SYSEX_END ) {
							return true;
						}
					}
					return false;
				}

				// TODO: error handling : skipping until the next probable message
				return _readBuffer.Count > 3;  // you will get decoding errors, but comm errors are skipped
			}


			private void ProcessMessage()
			{
				Debug.Assert( _readBuffer.Count > 0, "ProcessMessage() called without data" );
				Byte command = ReadBufferShift();

				//Debug.Log( "Processing Command " + command.ToString("X") + "(" + GetCommandWithoutChannel( command ).ToString("X") + ")" );
				//Debug.Log( "\t buffer =" + Tracer.Bytes2Array( _readBuffer ) );

				switch ( GetCommandWithoutChannel( command ) ) {
					case Commands.DIGITAL_MESSAGE:  ProcessDigitalMessage( command ) ; break ;
					case Commands.ANALOG_MESSAGE:   ProcessAnalogMessage ( command ) ; break ;
					case Commands.REPORT_VERSION:   ProcessReportVersion ( command ) ; break ;
					case Commands.SYSEX_START:      ProcessSysexMessage()            ; break ;
					default:                        ProcessUnknownCommand( command ) ; break;
				}
			}

			private byte ReadBufferShift() {
				Debug.Assert( _readBuffer.Count > 0 );

				byte data = _readBuffer[0];
				_readBuffer.RemoveAt( 0 );

				return data;
			}
			
			private Commands GetCommandWithoutChannel( byte command )
			{
				return (Commands) ( command >= 0xF0 ? command : command & 0xF0 );
			}
			
			
			private byte GetChannelOrPort( byte command )
			{
				return (byte) ( command & 0x0F );
			}
			
			
			private void ProcessSysexMessage()
			{
				CheckSysexMessageAndForProperNextMessage();
				
				Commands sysexCommand = (Commands) ReadBufferShift();
				//Debug.Log( "Processing Sysex Message " + sysexCommand.ToString("X") );
				switch ( sysexCommand ) {
					case Commands.REPORT_FIRMWARE:     ProcessReportFirmware()                 ; break ;
					case Commands.STRING_DATA:         ProcessStringData()                     ; break ;
					case Commands.CAPABILITY_RESPONSE: ProcessCapabilityResponse()             ; break ;
					case Commands.PIN_STATE_RESPONSE:  ProcessPinStateResponse()	           ; break ;
					case Commands.I2C_REPLY:           ProcessI2CReply()                       ; break ;
					default: 						   ProcessSysexData( (byte) sysexCommand ) ; break ;
				}
			}
			
			
			private void ProcessDigitalMessage( byte command )
			{
				byte bits0_6  = GetNonSysexByte();
				byte bits7_13 = GetNonSysexByte();

				_parent.Digital_IO_MessageReceived( GetChannelOrPort( command ), ( bits7_13 & 127 ) * 128 + ( bits0_6 & 127 ) );
				
				CheckForProperNextMessage( command, bits0_6, bits7_13 );
			}
			
			
			private void ProcessAnalogMessage( byte command )
			{
				byte bits0_6  = GetNonSysexByte();
				byte bits7_13 = GetNonSysexByte();
				
				_parent.Analog_IO_MessageReceived( GetChannelOrPort( command ), (uint) ( ( bits7_13 & 127 ) * 128 + ( bits0_6 & 127 ) ) );
				
				CheckForProperNextMessage( command, bits0_6, bits7_13 );
			}
			
			
			private void ProcessReportVersion( byte command )
			{
				byte majorVersion = GetNonSysexByte();
				byte minorVersion = GetNonSysexByte();

				_parent.QueryFirmwareReceived( majorVersion, minorVersion );
				
				CheckForProperNextMessage( command, majorVersion, minorVersion );
			}
			
			
			private void ProcessReportFirmware()
			{
				byte majorVersion = GetNonSysexByte();
				byte minorVersion = GetNonSysexByte();

				_parent.QueryFirmwareAndNameReceived( majorVersion, minorVersion , ReadSysexString() );
			}
			
			
			private void ProcessUnknownCommand( byte command )
			{
				//Debug.Log( "ProcessMessage(): unknown command -> command=" + command.ToString( "X2" ) + " channel=" + (int) GetChannelOrPort( command ) );
				_parent.UnknownCommandReceived( command );
			}
			
			
			private const byte END_OF_CURRENT_PIN = 127;
			
			private void ProcessCapabilityResponse()
			{
				byte nrOfDigitalPins            = 0;
				byte nrOfAnalogPins             = 0;

				List<byte> pinCapabilities = new List<byte>();
				ClearCapabilitiesList( pinCapabilities );
				List<List<byte>> capabilitiesPerPin = new List<List<byte>>();

				for ( byte capability = ReadBufferShift() ; capability != (byte) Commands.SYSEX_END ;  capability = _readBuffer.Count > 0  ? ReadBufferShift() : (byte) Commands.SYSEX_END ) {
					//Debug.Log( "read capability " + capability.ToString("X2") );
					if ( capability == END_OF_CURRENT_PIN ) {
						if ( pinCapabilities[ (int)PinModes.ANALOG ] > 0 ) {
							nrOfAnalogPins++;
						} else {
							nrOfDigitalPins++;
						}
						//Debug.Log( "Processed capabilities of pin " + capabilitiesPerPin.Count + " --> " + Tracer.Bytes2Array( pinCapabilities ) );
						capabilitiesPerPin.Add( pinCapabilities );
						pinCapabilities = new List<byte>();
						ClearCapabilitiesList( pinCapabilities );
					} else {
						byte resolution = ReadBufferShift();
						//Debug.Log( "\tread resolution " + resolution.ToString("X2") );
						Debug.Assert( resolution < 128, "all resolutions should be < 128" );
						pinCapabilities[ (int) capability ] = resolution;
					}
				}
				
				//Debug.Log( "nr of pins = " + capabilitiesPerPin.Count );
				_parent.PinCapabilitiesReceived( nrOfAnalogPins , nrOfDigitalPins , capabilitiesPerPin );
			}

			private void ClearCapabilitiesList( List<byte> pinCapabilities )
			{
				pinCapabilities.Clear();
				for ( PinModes pinMode = PinModes.INPUT ; pinMode <= PinModes.I2C ; pinMode++ ) {
					pinCapabilities.Add( 0 );
				}

			}
			
			
			private void ProcessPinStateResponse()
			{
				byte pin   = GetNonSysexByte();
				byte mode  = GetNonSysexByte();
				int value  = 0;
				
				for ( byte sysexByte = ReadBufferShift() ; sysexByte != (byte) Commands.SYSEX_END ; sysexByte = _readBuffer.Count > 0 ? ReadBufferShift() : (byte) Commands.SYSEX_END ) {
					value = value * 128 + sysexByte;
				}
				
				if (  mode < (byte) TOTAL_PIN_MODES ) {
					_parent._currentPinMode[ pin ] = (PinModes) mode;
					if ( value < 256 ) {
						_parent._pwmOutputData[ pin ] = (byte) value;
					}
				}
			}
			
			
			private void ProcessI2CReply()
			{
				uint address  = GetIntFromNextTwoDataItems();
				uint register = GetIntFromNextTwoDataItems();

				_parent.I2CReplyReceived( address , register , ReadSysexData() );
			}
			
			
			private void ProcessStringData()
			{
				_parent.SysexStringReceived( Commands.STRING_DATA, ReadSysexString() );
			}
			
			
			private void ProcessSysexData( byte sysexCommand )
			{
				_parent.SysexDataReceived( sysexCommand, ReadSysexData() );
			}
			
			
			private String ReadSysexString()
			{
				String sysexString = "";

				while  ( _readBuffer.Count > 0 && _readBuffer[ 0 ] != (byte) Commands.SYSEX_END ) {
					int value = ReadBufferShift();
					
					if ( _readBuffer[ 0 ] != (byte) Commands.SYSEX_END ) {
						value += ReadBufferShift() * 128;
					} else {
						// Odd situation, last char not a full size unicode char??
					}
					if ( value != 0 ) {
						sysexString += (char)value;
					}
				}
				byte endOfSysexString = ReadBufferShift();
				Debug.Assert( endOfSysexString == (byte) Firmata.Commands.SYSEX_END, "SYSEX_END expected, but got "
				                                                                     + endOfSysexString.ToString("X") );
				return sysexString;
			}
			
			
			private List<int> ReadSysexData()
			{
				List<int> sysexData = new List<int>();
				while  ( _readBuffer.Count > 0 && _readBuffer[ 0 ] != (byte) Commands.SYSEX_END ) {
					int value = ReadBufferShift();
					
					if ( _readBuffer[ 0 ] != (byte) Commands.SYSEX_END ) {
						value += ReadBufferShift() * 128;
					} else {
						// Odd situation, last char not a full size unicode char??
					}
					if ( value != 0 ) {
						sysexData.Add ( value );
					}
				}
				byte endOfSysexString = ReadBufferShift();
				Debug.Assert( endOfSysexString == (byte) Firmata.Commands.SYSEX_END, "SYSEX_END expected, but got "
				                                                                     + endOfSysexString.ToString("X") );
				return sysexData;
			}
			
			
			private byte GetNonSysexByte()
			{
				Debug.Assert( _readBuffer.Count > 0   );
				Debug.Assert( _readBuffer[ 0 ]  < 128 ); // GetNonSysexByte() data too large (%1)", _readBuffer[ 0 ]
				
				if ( _readBuffer.Count > 0 && _readBuffer[ 0 ] < 128 ) {
					return ReadBufferShift();
				} else {
					return 0;
				}
			}
			
			
			private uint GetIntFromNextTwoDataItems()
			{
				Debug.Assert( _readBuffer.Count > 0 );

				int leastSignificantByte = GetNonSysexByte();
				int  mostSignificantByte = GetNonSysexByte();
				
				return (uint) ( ( mostSignificantByte & 127 ) * 128 + ( leastSignificantByte & 127 ) );
			}
			
/*
			private void convertTwoByteArrayToValues( array : Array ) : void
			{
				for ( var toIndex : uint = 0 ; toIndex < array.length / 2 ; toIndex++ ) {
					var fromIndex : uint = toIndex * 2 ;
					array[ toIndex ] = ( array[ fromIndex ] & 127 ) + 128 * ( array[ fromIndex + 1 ] & 127 );
				}
				array.splice( toIndex );
			}
*/
			
			private void CheckForProperNextMessage( byte previousCommand , byte firstByte , byte secondByte )
			{
				if ( _readBuffer.Count != 0 ) {
					if ( IsImproperNextCommandAtIndex( 0 ) ) {
						Debug.Log( "Decoding Error for next message, current message ="
						          + previousCommand.ToString( "X2" ) + ", " + firstByte.ToString("X2") + ", "
						          + secondByte.ToString("X2") + ", _readBuffer = " + Tracer.Bytes2Array( _readBuffer ) );
					}
				}
			}
			
			
			private Boolean NOT_YET_ENOUGH_DATA_RECEIVED = false;
			
			private Boolean IsImproperNextCommandAtIndex( int index )
			{
				Debug.Assert( index >= 0                , "isImproperNextCommand() called with index < 0 (" + index + ")"                                              );
				Debug.Assert( index < _readBuffer.Count , "isImproperNextCommand() called with index (" + index + ") > available bytes(" + _readBuffer.Count + " )"    );
				Debug.Assert( _readBuffer.Count > 0     , "isImproperNextCommand() called without enough data ( " + _readBuffer.Count + " ) at least 3)"               );

				Commands nextCommand = GetCommandWithoutChannel( _readBuffer[index] );
				
				switch( nextCommand ) {
				case Commands.DIGITAL_MESSAGE:
				case Commands.REPORT_VERSION:
				case Commands.ANALOG_MESSAGE:
					if ( _readBuffer.Count < ( index + 3 ) )
						return NOT_YET_ENOUGH_DATA_RECEIVED;
					return ( _readBuffer[index+1] & 128 ) != 0 || ( _readBuffer[index+2] & 128 ) != 0;
				case Commands.SYSEX_START:
					if ( _readBuffer.Count <= ( index + 1 ) ) {
						return NOT_YET_ENOUGH_DATA_RECEIVED;
					}
					Commands sysexCommand = (Commands) _readBuffer[ index + 1 ];
					switch ( sysexCommand ) {
					case Commands.REPORT_FIRMWARE:
					case Commands.STRING_DATA:
					case Commands.CAPABILITY_RESPONSE:
					case Commands.PIN_STATE_RESPONSE:
					case Commands.I2C_REPLY:
						return false;
					}
					break;
				}
				return true;
			}
			
			
			private void CheckSysexMessageAndForProperNextMessage()
			{
				Debug.Assert( _readBuffer.Count > 2 , "FirmataReader.CheckSysexMessageAndForProperNextMessage() called without enough data (" + _readBuffer.Count + " at least 3)" );
				int i = 2;
				uint decodingErrors = 0;
				while ( i < _readBuffer.Count && _readBuffer[i] != (byte) Commands.SYSEX_END ) {
					if ( ( ((int) _readBuffer[i] ) & 128 ) != 0 ) {
						decodingErrors++;
					}
					i++;
				}
				if ( decodingErrors  > 0 ) {
					Debug.Log( "Warning: Decoding error(s) for sysex message, " + decodingErrors
					           + " byte(s) have high bit set (message=" + Tracer.Bytes2Array( _readBuffer ) + ")" );
				}
				
				if ( (i+1) < _readBuffer.Count ) {
					if ( IsImproperNextCommandAtIndex( i + 1 ) ) {
						Debug.Log( "Warning: Decoding Error for next message after sysex message (command="
						          + _readBuffer[i+1] + " index=" + (i+1) + "), current data="
						           + Tracer.Bytes2Array( _readBuffer ) );
					}
				}
			}

			#endregion
		}
	}
}

